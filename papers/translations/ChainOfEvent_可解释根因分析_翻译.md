# Chain-of-Event: 微服务可解释根因分析

> **原文标题**: Chain-of-Event: Interpretable Root Cause Analysis for Microservices through Automatically Learning Weighted Event Causality Graph
>
> **来源**: FSE Companion '24 (ACM SIGSOFT International Symposium on the Foundations of Software Engineering)
>
> **机构**: NetMan实验室（清华大学）

---

## 摘要

微服务架构中的根因分析（RCA）面临三大挑战：
1. **多模态数据兼容性**: 需要同时处理指标、日志、追踪数据
2. **可解释性和人类知识对齐**: 模型参数应有明确物理意义，便于SRE理解和优化
3. **自动因果学习**: 减少或消除手动配置需求

本文提出**Chain-of-Event (CoE)**，一个基于事件的RCA算法：
- 自动学习事件间的因果关系
- 参数具有明确物理意义
- 在全球Top-5电商系统上达到**98.8% Top-3准确率**

---

## 1. 引言

### 1.1 事件驱动的RCA框架

**核心思想**: 将多模态数据转换为统一的事件表示

**事件定义**:
```json
{
  "event": "High CPU Usage",
  "related_service": "service_A",
  "timestamp": "t1"
}
```

**事件类型**:
| 来源 | 事件示例 |
|-----|---------|
| 指标 | High CPU Usage, High GC |
| 日志 | Exception Raised |
| 追踪 | Service Client Error Spike |
| 操作 | Server Scaling, Code Deployment |

### 1.2 现有方法的局限性

| 方法 | 多模态 | 可解释性 | 自动学习 |
|-----|-------|---------|---------|
| Eadro | ✓ | ✗ (黑盒) | ✓ |
| Nezha | ✓ | △ (抽象) | ✓ |
| Groot | ✓ | ✓ | ✗ (需手动规则) |
| PDiagnose | ✓ | ✓ | ✗ (需手动阈值) |
| **CoE** | **✓** | **✓** | **✓** |

---

## 2. 系统架构

### 2.1 整体框架

```
┌──────────────────────────────────────────────────────────────┐
│                     Chain-of-Event (CoE)                      │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  多模态数据 → 事件转换                                    │ │
│  │                                                          │ │
│  │  指标 ─→ [High CPU, High GC, ...]                       │ │
│  │  日志 ─→ [Exception Raised, Error Logged, ...]          │ │
│  │  追踪 ─→ [Client Error Spike, Timeout, ...]             │ │
│  │  操作 ─→ [Deployment, Scaling, Config Change, ...]      │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              ↓                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  事件因果图自动学习                                       │ │
│  │                                                          │ │
│  │  参数1: P(e_j | e_i) - 事件i引发事件j的概率              │ │
│  │  参数2: Importance(e) - 事件在系统中的重要性             │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              ↓                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │  根因概率计算                                             │ │
│  │                                                          │ │
│  │  枚举事件链 → 计算链概率 → 聚合根因概率                  │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              ↓                                │
│  输出: 根因事件排名                                           │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### 2.2 关键参数的物理意义

| 参数 | 物理意义 | SRE理解 |
|-----|---------|--------|
| P(e_j\|e_i) | 事件i引发事件j的概率 | "CPU高导致GC频繁的可能性" |
| Importance(e) | 事件在系统中的重要性 | "这个事件对系统影响有多大" |

**优势**: SRE可以直接基于经验调整这些参数

---

## 3. 核心算法

### 3.1 事件因果图构建

**节点**: 各类事件
**边权重**: P(e_j | e_i) - 因果概率

**学习方法**:
```
给定历史故障数据:
1. 统计事件共现频率
2. 计算条件概率 P(e_j | e_i)
3. 过滤低概率边
4. 构建加权因果图
```

### 3.2 事件重要性学习

**思想**: 类似PageRank，重要事件被更多事件影响

**计算**:
```
Importance(e) = Σ P(e | e') × Importance(e')
```

### 3.3 根因概率计算

**事件链**: 从告警事件回溯到根因的路径

**例如**:
```
告警: Service Error
事件链1: Deployment → High CPU → Service Error
事件链2: Config Change → Timeout → Service Error
```

**概率计算**:
```
P(root=e_0) = Σ P(chain) × Importance(e_0)
           = Σ [P(e_1|e_0) × P(e_2|e_1) × ...] × Importance(e_0)
```

### 3.4 近似算法

**问题**: 枚举所有事件链计算量巨大

**解决**: 提出近似方法，只考虑高概率链

**理论保证**: 提供近似误差的严格上界

---

## 4. 实验

### 4.1 数据集

来自全球Top-5电商系统：
- **服务级数据集**: 5000+微服务
- **业务级数据集**: 业务流程事件

### 4.2 基线方法

| 类别 | 方法 |
|-----|------|
| 单模态 | MicroRCA, Dejavu, GTrace |
| 多模态 | Eadro, Nezha, Groot |

### 4.3 主要结果

**服务级数据集**:

| 方法 | Top-1 | Top-3 |
|-----|-------|-------|
| MicroRCA | 52.3% | 71.2% |
| Eadro | 61.5% | 82.4% |
| Nezha | 65.2% | 85.7% |
| **CoE** | **79.3%** | **98.8%** |

**业务级数据集**:

| 方法 | Top-1 | Top-3 |
|-----|-------|-------|
| Eadro | 68.4% | 87.2% |
| **CoE** | **85.3%** | **96.6%** |

### 4.4 可解释性验证

**案例**: 部署后CPU飙高

**CoE分析**:
```
事件链: Code Deployment → High CPU → Service Timeout
因果概率: P(High CPU | Deployment) = 0.72
根因: Code Deployment (置信度 0.85)
```

**SRE反馈**: "这个分析和我们的经验完全一致"

### 4.5 人类知识集成

**实验**: 让SRE根据经验调整参数

**结果**: 
- 准确率从79.3%提升到84.5%
- 证明参数对齐人类知识的价值

---

## 5. 与其他方法对比

### 5.1 与黑盒方法对比

| 维度 | CoE | Eadro |
|-----|-----|-------|
| 可解释性 | ✓ | ✗ |
| 参数意义 | 明确 | 隐晦 |
| SRE可调优 | ✓ | ✗ |
| 准确率 | 更高 | 较低 |

### 5.2 与规则方法对比

| 维度 | CoE | Groot |
|-----|-----|-------|
| 因果学习 | 自动 | 手动规则 |
| 维护成本 | 低 | 高 |
| 新场景适应 | 快 | 慢 |

---

## 6. 结论

CoE通过事件驱动的因果图学习，成功解决了微服务RCA的三大挑战：

1. **多模态兼容**: 统一事件表示
2. **可解释性强**: 参数有明确物理意义
3. **自动学习**: 无需手动配置规则

在大规模电商系统上达到98.8% Top-3准确率，且支持SRE知识集成。

---

## 附录：关键公式

### 因果概率计算
```
P(e_j | e_i) = Count(e_i → e_j) / Count(e_i)
```

### 事件重要性（类PageRank）
```
I(e) = (1-d) + d × Σ P(e|e') × I(e')
```

### 根因概率
```
P(root=e) = Σ_{chain} P(chain | root=e) × I(e)
```
